<!--pages/wxml/wxml.wxml-->
<!-- <text>pages/wxml/wxml.wxml</text> -->

<!-- 一。事件的处理的回顾-->
<!-- 事件绑定的三种写法： -->
<button bindtap="handleClick" size="mini">按钮</button>
<button bind:tap="handleClick" size="mini">按钮</button>
<button catch:tap="handleClick" size="mini">按钮</button>

<!-- 二 常见的一些事件 -->
<view 
class="box"
bind:touchstart="handletouchstart"
bind:touchmove="handletouchmove"
bind:touchend="handletouchend"
bind:tap="handletap"
bind:longpress="handlelongpress"
></view>

<!-- 三。事件对象的分析 event-->
<button size="mini" bindtap="handleEventClick" bind:touchend="handleeventend">事件对象</button>
<view class="outer" id="outer" bindtap="handleOuter">
  外层的view
  <view class="inner" id="inner" bindtap="handleInner">内层的view</view>
</view>

<!-- 四.   事件的传递参数  data-   -->
<view class="containers">
  <block wx:for="{{titles}}" wx:key="index">
    <view class="items" bindtap="handleItemClick" data-index="{{index}}" data-item="{{item}}">{{item}}</view>
  </block>
</view>

<!--五  事件冒泡和事件捕获 ---catch和bind的区别 -->
<!-- bind会一层一层传递 -->
<!-- catch会阻止事件的进一步传递 -->
<view class="view1" capture-catch:tap="handleCaptureView1" bindtap="handleBindView1">
  <view class="view2" capture-bind:tap="handleCaptureView2" bindtap="handleBindView2">
    <view class="view3" capture-bind:tap="handleCaptureView3" bindtap="handleBindView3"></view>
  </view>


</view>


<view>----------------------------------</view>



<!-- 1.wxml的格式 -->
<!-- 区分大小写 -->


<view>11</view>
<!-- <image /> -->
<input type="text" value="请输入内容" />

<!-- 2.Mustache语法 -->

<view>{{message}}</view>
<view>{{firstname}} {{lastname}}</view>
<view>{{firstname+ ' ' + lastname}}</view>
<view>{{age >= 18 ? '成年人' : '未成年人' }}</view>
<view>{{time}}</view>
<button size="mini" bindtap="handleSwitchColor">切换颜色</button>
<view class="box {{isActive ? 'active' :''}}">哈哈哈</view>

<!-- ------------------------条件判断--------------------- -->
<!-- 3. 条件判断  wx:if -->
<button size="mini" bindtap="handleSwitchShow">切换显示</button>
<view wx:if="{{isShow}}">哈哈哈哈哈</view>

<!-- wx:elif  wx:else-->
<button bindtap="handleIncrment" size="mini">分数递增6</button>
<view wx:if="{{score>=90}}">优秀</view>
<view wx:elif="{{score>=80}}">良好</view>
<view wx:elif="{{score>=70}}">及格</view>
<view wx:else>不及格</view>


<!-- 4.hidden属性和wx:if 在隐藏组件时候的区别-->

<!-- hidden将我们的组件隐藏时，该组件依然存在{display：none} -->
<!--wx:if将组件隐藏起来时候，该组件根本不存在（压根没有创建） -->
<view>----------------------------------------------------------</view>
<!-- 选择:如果切换的频率非常高的时候，选择使用hidden -->
<!-- 选择:显示与隐藏切换的频率非常的低，选择使用wx:if -->
<view wx:if="{{false}}">我是wx:if属性控制的内容</view>
<view hidden="{{true}}">我是通过 hidden属性控制的内容</view>



<!-- 5.列表渲染 -->
<!-- wx:for 的基础 -->
<!-- 1.1  遍历数组  字符串  数字 -->
<!-- <view wx:for="{{['abc','cba','nba']}}">{{item}}--------------------{{index}}</view>
<view wx:for="coderwhy">{{item}} ===={{index}}</view>
<view wx:for="{{9}}">{{item}}</view> -->


<!-- 1.2 block标签 ：在某些情况下，wx:if或者wx:for,可能需要一组组件包裹，

  方法1： 使用view 组件包裹，但是会消耗性能


  方法2： 使用block标签,并不是一个组件，仅仅是一个包装元素，不会在页面上进行渲染，只接受控制属性，
  使用block的两个好处：
  ①  将需要进行遍历或者判断的内容进行包裹
  ② 将遍历或者判断的属性放在block标签中，不影响普通属性的阅读，提高代码的可读性
  ③  性能比view更高
  <block></block>

-->

<!--1.3 给item index 起名字   wx:for-item   wx:for-index-->
<!-- 默认情况下，item-index是固定的，但是在某些情况下，我们可能想使用其他名称，或者当多层遍历的时候，名字会重复，这个时候，我们可以指定item 和index的名称 -->


<!-- <view wx:for="{{movies}}"  wx:for-item="movie"  wx:for-index="i">{{movie}}====={{i}}</view>

<block wx:for='{{nums}}' wx:for-item="innernums">
 <block wx:for="{{innernums}}">
   <view>{{item}}</view>
 </block>
</block> -->


<!-- 1.4 添加key的作用:提高性能,高效地提升虚拟DOM-->

<!-- <view class="container1">
  <view wx:for="{{letters}}" wx:key="index">{{item}}</view>
</view> -->


<!-- 1.5 template 模板 -->
<!--之前的时候小程序是不支持自定义组件的，为了进行代码的复用：template -->
<!-- wxml提供模板，可以在模板中定义代码片段，在不同的地方调用，是一种wxml代码的复用机制 -->
<!--使用name属性，作为模板的名字，然后在<template/>  内定义代码片段 -->
<!-- 模板中包裹的内容，在没有被使用之前，是不会进行任何的渲染的 -->

<!-- <template name="contentItem">
  <button size="mini">{{btntext}}</button>
  <view>{{content}}</view>
</template> -->

<!-- 1.5.1  可以把模板抽离到一个单独的wxml文件中，使用import来引用，可以在多个页面进行使用 -->
<!-- <import src="模板文件的路径"></import> -->
<import src="../../wxml/template.wxml"></import>

<template is="contentItem" data="{{btntext:'按钮',content:'内容'}}"/>
<template is="contentItem" data="{{btntext:'按钮1',content:'内容1'}}"/>
<template is="contentItem" data="{{btntext:'按钮2',content:'内容2'}}"/>

<!-- 1.5.2 include是不可以导入模板的,但是可以进行循环的导入的 ,import 相反-->
<!-- <include src="../../wxml/template.wxml"/> -->

<!-- 1.5.3 wxml中不能进行递归导入的，也就是A 引用了B的template,不会引入B中C的template -->



<!-- 结论： include是不可以导入模板的
  关于wxml的导入有两种方式：
  
  import导入：
  1.主要是导入template
  2.特点：不能进行递归导入

  include引入：
  1.将公共的wxml中的组件抽取到一个文件中
  2.特点：  不能导入template/wxs,可以进行递归导入

 -->